就是把一些相同的功能封装成一个函数，就可以反复调用

`$1:用于接收第1个参数`
`$n:用于接收第n个参数`

`$?:用来接收返回的状态`
`$*:接收所有参数`
`$#:接收参数的个数`

## 1.自定义函数1      
### vim f1.sh
```
#!/bin/bash
#自定义函数sum1
function  sum1(){
  a=10
  b=20
  c=$[a + b]  #$[] 这个具有计算机器功能
  echo $c 
}

#函数不会单独执行，被调用才会执行
sum1  #调用函数
```

###  执行脚本
bash  f1.sh
## 2.自定义函数2      
### vim f2.sh
```
#!/bin/bash
#自定义函数sum1
function  sum1(){
  a=$1    #接收第1个参数
  b=$2     #接收第2个参数
  c=$[a + b]  #$[] 这个具有计算机器功能
  echo $c 
}
#函数不会单独执行，被调用才会执行
sum1 10 15   #调用函数，有2个参数，10传给$1 ,  15传给$2
```

### 执行脚本
bash  f2.sh
## 3.自定义函数3      
### vim f3.sh
```
#!/bin/bash
#自定义函数sum1
function  sum1(){
  a=$1    #接收第1个参数
  b=$2     #接收第2个参数
  c=$[a + b]  #$[] 这个具有计算机器功能
  return $c   #return返回的不是结果，是一种状态，用$?来看状态
}

#函数不会单独执行，被调用才会执行
sum1 200 500   #调用函数，有2个参数，10传给$1 ,  15传给$2
echo $?
```


### 执行脚本
bash  f3.sh
## 4.自定义函数4      
### vim f4.sh
```
#!/bin/bash
#自定义函数sum1
function  sum4(){
  s=0
  for i in $*   #$* = 1 2 3 4 5 6 7 8 9 10 , i会循环每一个数字
  do
     s=$[s + i]
  done
  echo $s    #1到10的累计求和
  echo $#    #统计参数的个数
}

#函数不会单独执行，被调用才会执行
sum4 1 2 3 4 5 6 7 8 9 10  #把10个数传给$*
```
### 执行脚本
bash  f4.sh
## 5.自定义函数4      
### vim f4.sh
```
#!/bin/bash
#自定义函数sum1
function  sum4(){
  echo $#
  echo $*
}

#函数不会单独执行，被调用才会执行
sum4 $*  
```

### 执行脚本(外部传参)
bash  f4.sh  1 2 3 4 5 6 7 8 9 10
### 逻辑：
①：在执行bash  f4.sh  1 2 3 4 5 6 7 8 9 10他的时候，把1到10传给 (sum4 $*)中的$*
②：此时此刻，sum4 $* 变成了 sum4 1 2 3 4 5 6 7 8 9 10
③：把sum4 1 2 3 4 5 6 7 8 9 10 传给 function  sum4()中的$#和$*
## 6.外传传参应用      
### vim f5.sh
```
#!/bin/bash
#自定义函数f1
f1(){        #function可以忽略不写
   mkdir  -p  /year/month/day
}

#自定义函数f2
f2(){
  rm -rf /year/month/day
}


#使用自定义函数（$1用于接收外部的第1个参数）
if [ $1 -eq 1 ];then
  f1  #调用自定义函数f1
elif [ $1 -eq 2 ];then
  f2  #调用自定义函数f1
else
  echo  哈哈
fi
```
### 执行脚本
bash f5.sh 1    ##把这里面的1传给 $1
bash f5.sh 2    ##把这里面的2传给 $1